"""BT Mesh Client Application"""
from __future__ import annotations


import asyncio
import time
from datetime import datetime, timedelta, timezone

from bluetooth_mesh.application import Application, Element, Capabilities
from bluetooth_mesh.messages.config import GATTNamespaceDescriptor
from bluetooth_mesh.messages.time import TimeOpcode, TimeRole, CURRENT_TAI_UTC_DELTA
from bluetooth_mesh.messages.generic.onoff import GenericOnOffOpcode
from bluetooth_mesh.messages.generic.battery import GenericBatteryOpcode
from bluetooth_mesh.messages.sensor import SensorOpcode, SensorSetupOpcode
from bluetooth_mesh.messages.vendor.thermostat import (
    ThermostatOpcode,
    ThermostatSubOpcode,
    ThermostatMode,
    ThermostatStatusCode
)

from bluetooth_mesh.models import ConfigClient, HealthClient
from bluetooth_mesh.models.generic.onoff import GenericOnOffClient
from bluetooth_mesh.models.generic.level import GenericLevelClient
from bluetooth_mesh.models.generic.dtt import GenericDTTClient
from bluetooth_mesh.models.generic.ponoff import GenericPowerOnOffClient
from bluetooth_mesh.models.generic.battery import GenericBatteryClient
from bluetooth_mesh.models.sensor import SensorServer, SensorSetupServer, SensorClient
from bluetooth_mesh.models.scene import SceneClient
from bluetooth_mesh.models.light.lightness import LightLightnessClient
from bluetooth_mesh.models.light.ctl import LightCTLClient
from bluetooth_mesh.models.light.hsl import LightHSLClient
from bluetooth_mesh.models.vendor.thermostat import ThermostatClient
from bluetooth_mesh.models.time import TimeServer, TimeSetupServer

from . import BtMeshModelId

from ..const import (
    DEFAULT_DBUS_APP_PATH,
    G_SEND_INTERVAL,
    G_TIMEOUT,
    G_UNACK_RETRANSMISSIONS,
    G_UNACK_INTERVAL,
    G_MESH_SENSOR_CACHE_TIMEOUT,
    G_MESH_CACHE_UPDATE_TIMEOUT,
    G_MESH_CACHE_INVALIDATE_TIMEOUT,
)

import logging
_LOGGER = logging.getLogger(__name__)



class MainElement(Element):
    LOCATION = GATTNamespaceDescriptor.MAIN
    MODELS = [
        ConfigClient,
        HealthClient,
        GenericOnOffClient,
        GenericDTTClient,
        GenericPowerOnOffClient,
        GenericBatteryClient,
        SceneClient,
        GenericLevelClient,
        SensorClient,
        LightLightnessClient,
        LightCTLClient,
        LightHSLClient,
        ThermostatClient,
        TimeServer,
        TimeSetupServer
    ]


class BtMeshApplication(Application):
    COMPANY_ID = 0x05f1  # Linux Foundation
    PRODUCT_ID = 0x4148  # HA - HomeAssistant
    VERSION_ID = 1
    ELEMENTS = {
        0: MainElement,
    }
    CAPABILITIES = [Capabilities.OUT_NUMERIC]

    CRPL = 32768
    PATH = DEFAULT_DBUS_APP_PATH
    TOKEN = None


    # TODO: add comment
    _sensor_cache: dict
    _generic_onoff_cache: dict
    _cache: dict

    def __init__(self, path, token=None):
        """Initialize bluetooth_mesh application."""
        loop = asyncio.get_event_loop()
        super().__init__(loop)

        self.PATH = path
        self.TOKEN = token

        # FixMe: callback interface to separetly class
        self.pin_cb = None

        self._event_loop = None

        self._sensor_cache = dict()
        self._generic_onoff_cache = dict()
        self._cache = dict()


    ##################################################
    def display_numeric(self, type: str, number: int):
        """...."""
        if self.pin_cb:
            self.pin_cb._cb_display_numeric(type, number)

    async def mesh_join(self, pin_cb=None):
        """...."""
        self.pin_cb = pin_cb
        async with self:
            token = await self.join()
        return token
    ##########################################


    # cache
    def cache_get(self, address, model_id, extra_key=None) -> (bool, any):
        key = "%04x_%x_%s" % (address, model_id, str(extra_key))
        if key in self._cache:
            line = self._cache[key]
            if 'last_update' in line and 'data' in line and (line['last_update'] + G_MESH_CACHE_INVALIDATE_TIMEOUT) >= time.time():
                valid = (line['last_update'] + G_MESH_CACHE_UPDATE_TIMEOUT) >= time.time()
                return (valid, line['data'])

        return (False, None)

    def cache_update(self, address, model_id, data, extra_key=None):
        key = "%04x_%x_%s" % (address, model_id, str(extra_key))
        self._cache[key] = { 'last_update': time.time(), 'data': data }

    async def cache_proxy(self, address, model_id, async_def_get, extra_key=None):
        (valid, line) = self.cache_get(address, model_id, extra_key=extra_key)
        if valid and line is not None:
            return line
        else:
            try:
                _result = await async_def_get
                result = _result[address]
#                _LOGGER.debug("cache_proxy(): %s" % (result))
            except Exception:
                result = None

            if result is not None:
                self.cache_update(address, model_id, result, extra_key=extra_key)
                return result
            elif line is not None:
                return line
            else:
                return None


    # Scheduller
    async def _task_sched_routine(self, hass):
        while True:
            # process Set queue

            # process Get queue

            #_LOGGER.debug("Mesh Application scheduller task...");
            await asyncio.sleep(5)

    def sched_start(self, hass):
        hass.loop.create_task(self._task_sched_routine(hass))


    # Time Server

    def time_server_init(self):

        # Time Server message handlers
        def receive_get(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            _LOGGER.debug("Time Get: receive %04x->%04x" % (_source, _destination))

            system_timezone_offset = time.timezone * -1
            system_timezone = timezone(offset=timedelta(seconds=system_timezone_offset))
            date = datetime.now(system_timezone)

            server = self.elements[0][TimeServer]
            self.loop.create_task(
                server.time_status(
                    _source,
                    _app_index,
                    date,
                    timedelta(seconds=CURRENT_TAI_UTC_DELTA),
                    timedelta(0),
                    True
                )
            )


        def receive_time_zone_get(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            _LOGGER.debug("Time Zone Get: receive %04x->%04x" % (_source, _destination))

            system_timezone_offset = time.timezone * -1
            system_timezone_delta = timedelta(seconds=system_timezone_offset)

            server = self.elements[0][TimeServer]
            self.loop.create_task(
                server.time_zone_status(
                    _source,
                    _app_index,
                    system_timezone_delta,
                    system_timezone_delta,
                    0
                )
            )

        def receive_tai_utc_delta_get(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            _LOGGER.debug("TAI-UTC Delta Get: receive %04x->%04x" % (_source, _destination))

            server = self.elements[0][TimeServer]
            self.loop.create_task(
                server.tai_utc_delta_status(
                    _source,
                    _app_index,
                    CURRENT_TAI_UTC_DELTA,
                    CURRENT_TAI_UTC_DELTA,
                    0
                )
            )


        # Time Setup Server message handlers
        def receive_set(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            _LOGGER.debug("Get: receive %04x->%04x" % (_source, _destination))

            server = self.elements[0][TimeServer]
            self.loop.create_task(
                server.time_status(
                    _source,
                    _app_index,
                    message.time_set.date,
                    message.time_set.tai_utc_delta,
                    message.time_set.uncertainty,
                    message.time_set.time_authority,
                )
            )

        server = self.elements[0][TimeServer]
        server.app_message_callbacks[TimeOpcode.TIME_GET].add(receive_get)
        server.app_message_callbacks[TimeOpcode.TIME_ZONE_GET].add(receive_time_zone_get)
        server.app_message_callbacks[TimeOpcode.TAI_UTC_DELTA_GET].add(receive_tai_utc_delta_get)

        server = self.elements[0][TimeSetupServer]
        server.app_message_callbacks[TimeOpcode.TIME_SET].add(receive_set)





    # Switch

    def mesh_generic_onoff_cache_update(self, address, status):
        self._generic_onoff_cache[address] = { 'last_update': time.time(), 'status': status }

    def onoff_init_receive_status(self):
        def receive_status(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            #_LOGGER.debug("receive %04x->%04x %s" % (_source, _destination, message))
            #self.switch_cache_update(_source, message['sensor_status']
            pass

        client = self.elements[0][GenericOnOffClient]
        client.app_message_callbacks[GenericOnOffOpcode.GENERIC_ONOFF_STATUS].add(receive_status)


    async def mesh_generic_onoff_get(self, address, app_index):
    #async def mesh_generic_onoff_get(self, entity):
        """Get GenericOnOff state"""

#        _line = self.cache_get(address, BtMeshModelId.GenericOnOffServer);
#        _LOGGER.debug("Generic OnOff address %04x" % (address))
#        _LOGGER.debug(_line)

        #address = entity.unicast_addr;
        #app_index = entity.app_index

        line = self._generic_onoff_cache.setdefault(address, None)
        if line is not None and (line['last_update'] + G_MESH_CACHE_INVALIDATE_TIMEOUT) < time.time():
            _LOGGER.debug("[%04x] expaired %d" % (address, time.time() - line['last_update']))
            line = None

        if line is None or (line['last_update'] + G_MESH_CACHE_UPDATE_TIMEOUT) < time.time():
            client = self.elements[0][GenericOnOffClient]
            _result = await client.get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
            result = _result[address]
            if result is not None:
#                self.cache_update(address, BtMeshModelId.GenericOnOffServer, result);
                self.mesh_generic_onoff_cache_update(address, result.present_onoff != 0)
                return result.present_onoff != 0
            elif line is not None:
                return line['status']
            else:
                return None
        else:
            return line['status']


    async def mesh_generic_onoff_set(self, address, app_index, state):
        """Set GenericOnOff state"""
        client = self.elements[0][GenericOnOffClient]
        #await client.set([address], app_index=app_index, onoff=state, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
        await client.set_unack(address, app_index=app_index, onoff=state, send_interval=G_UNACK_INTERVAL, retransmissions=G_UNACK_RETRANSMISSIONS)
        self.mesh_generic_onoff_cache_update(address, state)



    # LightLightness
    async def mesh_light_lightness_set(self, address, app_index, lightness):
        """Set LightLightness lightness"""
        client = self.elements[0][LightLightnessClient]
        await client.set([address], app_index=app_index, lightness=lightness, transition_time=0.0, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)


    async def mesh_light_ctl_get(self, address, app_index):
        """Get LightCTL state"""
        client = self.elements[0][LightCTLClient]
        result = await client.get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
        return result[address]

    async def mesh_light_ctl_set(self, address, app_index, lightness, temperature):
        """Set LightCTL temperature"""
        client = self.elements[0][LightCTLClient]
        await client.set_unack(address,
                               app_index=app_index,
                               ctl_lightness=lightness,
                               ctl_temperature=temperature,
                               ctl_delta_uv=0,
                               transition_time=0.0)

    async def mesh_light_ctl_temperature_range_get(self, address, app_index):
        """Get LightCTL temperature range"""
        client = self.elements[0][LightCTLClient]
        result = await client.temperature_range_get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
        return result[address]


    async def mesh_light_hsl_get(self, address, app_index):
        """Get LightHSL state"""
        client = self.elements[0][LightHSLClient]
        result = await client.get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
        return result[address]

    async def mesh_light_hsl_set(self, address, app_index, lightness, hue, saturation):
        """Set LightHSL lightness, hue and saturation"""
        client = self.elements[0][LightHSLClient]
        await client.set_unack(address, app_index=app_index,
                               hsl_lightness=lightness,
                               hsl_hue=hue,
                               hsl_saturation=saturation,
                               transition_time=0.0)




    # Sensor

    def sensor_init_receive_status(self):
        def receive_status(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
            #_LOGGER.debug("receive %04x->%04x" % (_source, _destination))
            self.sensor_cache_update(_source, message['sensor_status'])

        client = self.elements[0][SensorClient]
        client.app_message_callbacks[GenericOnOffOpcode.GENERIC_ONOFF_STATUS].add(receive_status)

    def sensor_cache_update(self, addr, sensor_status):
        for property in sensor_status:
            try:
                property_id = property['sensor_setting_property_id']
                key = "%04x.%04x" % (addr, property_id)
                self._sensor_cache[key] = { 'last_update': time.time(), 'property': property }
            except Exception:
                pass

    async def sensor_descriptor_get(self, address, app_index):
        client = self.elements[0][SensorClient]
        try:
            result = await client.descriptor_get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
            return result[address];
        except Exception:
            _LOGGER.error("sensor_descriptor_get(): address=%04x, app_index=%d, %s" % (address, app_index, Exception))

        return None

    async def sensor_get(self, addr, app_index, property_id):
        key = "%04x.%04x" % (addr, property_id)
        line = self._sensor_cache.setdefault(key, None)

        if line == None or (line['last_update'] + G_MESH_SENSOR_CACHE_TIMEOUT) < time.time():
            client = self.elements[0][SensorClient]
            try:
                result = await client.get([addr], app_index=app_index,
                                          send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
                self.sensor_cache_update(addr, result[addr])
                line = self._sensor_cache.setdefault(key, None)
            except Exception:
                _LOGGER.error("failed to get Sensor, addr: %04x, app_index: %d %s" %
                              (addr, app_index, Exception))
                return None

        return line['property']


    # Generic Battery
    def generic_battery_init_receive_status(self):
        def receive_status(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
#            _LOGGER.debug("receive %04x->%04x %s" % (_source, _destination, message))
            self.cache_update(_source, BtMeshModelId.GenericBatteryServer, message['generic_battery_status'])

        client = self.elements[0][GenericBatteryClient]
        client.app_message_callbacks[GenericBatteryOpcode.GENERIC_BATTERY_STATUS].add(receive_status)

    async def generic_battery_get(self, address, app_index):
        """Get GenericBattery state"""

        (valid, line) = self.cache_get(address, BtMeshModelId.GenericBatteryServer)
        if valid and line is not None:
            return line.battery_level
        else:
            client = self.elements[0][GenericBatteryClient]
            _result = await client.get([address], app_index=app_index, send_interval=G_SEND_INTERVAL, timeout=G_TIMEOUT)
            result = _result[address]
            if result is not None:
                self.cache_update(address, BtMeshModelId.GenericBatteryServer, result)
                return result.battery_level
            elif line is not None:
                return line.battery_level
            else:
                return None


    # Vendor Thermostat

    def thermostat_init_receive_status(self):
        def receive_status(
            _source: int,
            _app_index: int,
            _destination: Union[int, UUID],
            message: ParsedMeshMessage,
        ):
#            _LOGGER.debug("receive %04x->%04x %s" % (_source, _destination, message))
            vendor_message = message['vendor_thermostat']
            if vendor_message.subopcode == ThermostatSubOpcode.THERMOSTAT_STATUS:
#                _LOGGER.debug("receive %04x->%04x %s" % (_source, _destination, vendor_message.thermostat_status))
                if vendor_message.thermostat_status.status_code == ThermostatStatusCode.GOOD:
                    self.cache_update(
                        _source,
                        (BtMeshModelId.ThermostatServer << 8) + ThermostatSubOpcode.THERMOSTAT_STATUS,
                        vendor_message.thermostat_status
                )
            elif vendor_message.subopcode == ThermostatSubOpcode.THERMOSTAT_RANGE_STATUS:
#                _LOGGER.debug("receive %04x->%04x %s" % (_source, _destination, vendor_message.thermostat_range_status))
                self.cache_update(
                    _source,
                    (BtMeshModelId.ThermostatServer << 8) + ThermostatSubOpcode.THERMOSTAT_RANGE_STATUS,
                    vendor_message.thermostat_range_status
                )
                pass


        client = self.elements[0][ThermostatClient]
        client.app_message_callbacks[ThermostatOpcode.VENDOR_THERMOSTAT].add(receive_status)

    async def thermostat_get(self, address, app_index):
        """Get Vendor Thermostat state"""
        (valid, line) = self.cache_get(address, (BtMeshModelId.ThermostatServer << 8) + ThermostatSubOpcode.THERMOSTAT_STATUS)
        if valid and line is not None:
            return line
        else:
            client = self.elements[0][ThermostatClient]
            try:
                _result = await client.get(
                    [address],
                    app_index=app_index,
                    send_interval=G_SEND_INTERVAL,
                    timeout=G_TIMEOUT,
                )
                result = _result[address]
            except Exception:
                result = None
            if result is not None:
                self.cache_update(address, BtMeshModelId.ThermostatServer, result)
                return result
            elif line is not None:
                return line
            else:
                return None

    async def thermostat_range_get(self, address, app_index):
        """Get Vendor Thermostat range"""
        client = self.elements[0][ThermostatClient]
        return await self.cache_proxy(
            address,
            BtMeshModelId.ThermostatServer,
            client.range_get(
                [address],
                app_index=app_index,
                send_interval=G_SEND_INTERVAL,
                timeout=G_TIMEOUT,
            ),
            extra_key=ThermostatSubOpcode.THERMOSTAT_RANGE_STATUS
        )

#        (valid, line) = self.cache_get(
#            address,
#            BtMeshModelId.ThermostatServer,
#            extra_key=ThermostatSubOpcode.THERMOSTAT_RANGE_STATUS
#        )
#        if valid and line is not None:
#            return line
#        else:
#            client = self.elements[0][ThermostatClient]
#            try:
#                _result = await client.range_get(
#                    [address],
#                    app_index=app_index,
#                    send_interval=G_SEND_INTERVAL,
#                    timeout=G_TIMEOUT,
#                )
#                result = _result[address]
#            except Exception:
#                result = None
#            if result is not None:
#                self.cache_update(
#                    address, BtMeshModelId.ThermostatServer,
#                    result,
#                    extra_key=ThermostatSubOpcode.THERMOSTAT_RANGE_STATUS
#                )
#                return result
#            elif line is not None:
#                return line
#            else:
#                return None

    async def thermostat_set(self, address, app_index, onoff, temperature):
        """Get Vendor Thermostat state"""
        client = self.elements[0][ThermostatClient]

        try:
            result = await client.set(
                [address],
                app_index=app_index,
                onoff=onoff,
                mode=ThermostatMode.MANUAL,
                temperature=temperature,
                send_interval=G_SEND_INTERVAL,
                timeout=G_TIMEOUT,
            )
            return result[address]
        except Exception:
            return None
